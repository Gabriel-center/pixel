<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Advanced Pixel Painter - Last Pixel Blink (Fixed)</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #111;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
        }

        #app-wrapper {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            background-color: #111;
        }

        #canvas-container {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            background-color: #282828;
            display: flex;
        }

        #paint-canvas {
            display: block;
            cursor: crosshair;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            background-color: #000;
        }

        #preview-canvas { /* Still used, but now for the last painted pixel */
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 5;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
        }


        #toolbar {
            background-color: #333;
            color: white;
            padding: 8px 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
            box-sizing: border-box;
            z-index: 10;
            flex-wrap: wrap;
        }

        #toolbar label, #toolbar span {
            margin-right: 3px;
            white-space: nowrap;
            font-size: 0.9em;
        }
        #toolbar input[type="number"] {
            width: 50px;
            padding: 3px;
            margin-right: 5px;
            font-size: 0.9em;
        }

        #color-picker {
            width: 35px;
            height: 22px;
            border: none;
            padding: 0;
            cursor: pointer;
            background-color: transparent;
        }

        .color-swatch {
            width: 18px;
            height: 18px;
            border: 1px solid #555;
            cursor: pointer;
            display: inline-block;
            margin: 0 1px;
        }
        .color-swatch:hover { transform: scale(1.1); }
        .color-swatch.active { border-color: #fff; box-shadow: 0 0 3px #fff; }

        #toolbar button {
            padding: 5px 8px;
            background-color: #555;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.85em;
        }
        #toolbar button:hover { background-color: #777; }
        #toolbar button.active { background-color: #007bff; }

        .toolbar-group {
            display: flex;
            align-items: center;
            border-left: 1px solid #444;
            padding-left: 8px;
            margin-left: 5px;
        }
        .toolbar-group:first-child {
            border-left: none;
            padding-left: 0;
            margin-left: 0;
        }
        #clear-confirmation-div {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #clear-confirmation-div span {
            font-size: 0.85em;
        }
    </style>
</head>
<body>
    <div id="app-wrapper">
        <div id="canvas-container">
            <canvas id="paint-canvas"></canvas>
            <canvas id="preview-canvas"></canvas>
        </div>
        <div id="toolbar">
            <div class="toolbar-group">
                <label for="color-picker">Color:</label>
                <input type="color" id="color-picker" value="#FF0000">
                <div id="swatches-container"></div>
            </div>

            <div class="toolbar-group">
                <button id="eraser-button">Eraser</button>
                <button id="clear-button">Clear</button>
                <div id="clear-confirmation-div" style="display: none;">
                    <span>Sure?</span>
                    <button id="confirm-clear-yes">Yes</button>
                    <button id="confirm-clear-no">No</button>
                </div>
            </div>

            <div class="toolbar-group">
                <label for="canvas-width-input">W:</label>
                <input type="number" id="canvas-width-input" min="1" value="640">
                <label for="canvas-height-input">H:</label>
                <input type="number" id="canvas-height-input" min="1" value="480">
                <button id="set-canvas-size-button">Set Size</button>
            </div>

            <div class="toolbar-group">
                <button id="download-button">Download</button>
                <input type="file" id="load-image-input" accept="image/*" style="display: none;">
                <button id="load-button">Load Image</button>
            </div>
            
            <div class="toolbar-group">
                <button id="fullscreen-button">Fullscreen</button>
                <span>Last: <span id="last-pixel-coords">-</span></span>
            </div>
        </div>
    </div>

    <script>
        const appWrapper = document.getElementById('app-wrapper');
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.getElementById('paint-canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        const previewCanvas = document.getElementById('preview-canvas');
        const previewCtx = previewCanvas.getContext('2d');

        const colorPicker = document.getElementById('color-picker');
        const swatchesContainer = document.getElementById('swatches-container');
        
        const clearButton = document.getElementById('clear-button');
        const clearConfirmationDiv = document.getElementById('clear-confirmation-div');
        const confirmClearYesButton = document.getElementById('confirm-clear-yes');
        const confirmClearNoButton = document.getElementById('confirm-clear-no');

        const eraserButton = document.getElementById('eraser-button');
        const fullscreenButton = document.getElementById('fullscreen-button');
        const lastPixelCoordsDisplay = document.getElementById('last-pixel-coords');

        const canvasWidthInput = document.getElementById('canvas-width-input');
        const canvasHeightInput = document.getElementById('canvas-height-input');
        const setCanvasSizeButton = document.getElementById('set-canvas-size-button');
        const downloadButton = document.getElementById('download-button');
        const loadImageInput = document.getElementById('load-image-input');
        const loadButton = document.getElementById('load-button');

        let currentColor = colorPicker.value;
        const eraserColor = '#FFFFFF';
        const defaultCanvasColor = '#000000';

        let isPainting = false;
        let isErasing = false;
        let lastPaintedPixel = null; // { x, y } in CSS pixels
        let currentDPR = window.devicePixelRatio || 1;

        let specifiedCSSWidth = 0;
        let specifiedCSSHeight = 0;
        let initialSizeApplied = false;

        let previewBlinkState = false;
        let blinkInterval = null;

        const predefinedSwatches = [
            '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF',
            '#000000', '#FFFFFF', '#808080', '#FFA500', '#A52A2A', '#4CAF50'
        ];

        const colorKeyMap = {
            '1': predefinedSwatches[0], // Red
            '2': predefinedSwatches[1], // Green
            '3': predefinedSwatches[2], // Blue
            '4': predefinedSwatches[3], // Yellow
            '5': predefinedSwatches[4], // Magenta/Pink
            '6': predefinedSwatches[5], // Cyan
            '7': predefinedSwatches[9], // Orange
            '8': predefinedSwatches[8], // Gray
            '9': predefinedSwatches[7], // White
            '0': predefinedSwatches[6], // Black
        };


        // --- UTILITY FUNCTIONS ---
        function hexToRgb(hex) { const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null; }
        function rgbToCss(rgbObj) { if (!rgbObj) return ''; return `rgb(${rgbObj.r}, ${rgbObj.g}, ${rgbObj.b})`; }
        function updateActiveSwatch(selectedHexColor) {
            const selectedRgbCss = selectedHexColor ? rgbToCss(hexToRgb(selectedHexColor)) : null;
            document.querySelectorAll('.color-swatch').forEach(swatch => {
                swatch.classList.toggle('active', selectedRgbCss && swatch.style.backgroundColor === selectedRgbCss);
            });
            if (isErasing) document.querySelectorAll('.color-swatch.active').forEach(s => s.classList.remove('active'));
        }
        function createSwatches() {
            predefinedSwatches.forEach(color => {
                const swatch = document.createElement('div');
                swatch.classList.add('color-swatch');
                swatch.style.backgroundColor = color;
                swatch.title = color;
                swatch.addEventListener('click', () => {
                    setColor(color);
                });
                swatchesContainer.appendChild(swatch);
            });
        }

        function setColor(newColor) {
            currentColor = newColor;
            colorPicker.value = newColor;
            isErasing = false;
            eraserButton.classList.remove('active');
            eraserButton.style.backgroundColor = '';
            updateActiveSwatch(newColor);
        }


        // --- CANVAS SIZING AND PRESERVATION ---
        function resizeAndPreserveCanvas() {
            let oldImageData = null;
            let prevCanvasActualCSSWidth = 0;
            let prevCanvasActualCSSHeight = 0;

            if (canvas.width > 0 && canvas.height > 0) {
                prevCanvasActualCSSWidth = parseFloat(canvas.style.width) || (canvas.width / currentDPR);
                prevCanvasActualCSSHeight = parseFloat(canvas.style.height) || (canvas.height / currentDPR);
                oldImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            }
            
            currentDPR = window.devicePixelRatio || 1;

            let targetCSSWidth, targetCSSHeight;
            if (initialSizeApplied) {
                targetCSSWidth = specifiedCSSWidth;
                targetCSSHeight = specifiedCSSHeight;
            } else {
                const containerRect = canvasContainer.getBoundingClientRect();
                targetCSSWidth = Math.max(1, Math.floor(containerRect.width));
                targetCSSHeight = Math.max(1, Math.floor(containerRect.height));
                specifiedCSSWidth = targetCSSWidth;
                specifiedCSSHeight = targetCSSHeight;
                canvasWidthInput.value = specifiedCSSWidth;
                canvasHeightInput.value = specifiedCSSHeight;
                initialSizeApplied = true;
            }

            canvas.width = Math.round(targetCSSWidth * currentDPR);
            canvas.height = Math.round(targetCSSHeight * currentDPR);
            canvas.style.width = `${targetCSSWidth}px`;
            canvas.style.height = `${targetCSSHeight}px`;
            
            previewCanvas.width = canvas.width;
            previewCanvas.height = canvas.height;
            previewCanvas.style.width = canvas.style.width;
            previewCanvas.style.height = canvas.style.height;

            ctx.setTransform(currentDPR, 0, 0, currentDPR, 0, 0);
            previewCtx.setTransform(currentDPR, 0, 0, currentDPR, 0, 0);

            ctx.fillStyle = defaultCanvasColor;
            ctx.fillRect(0, 0, targetCSSWidth, targetCSSHeight);

            if (oldImageData) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = oldImageData.width;
                tempCanvas.height = oldImageData.height;
                tempCanvas.getContext('2d').putImageData(oldImageData, 0, 0);
                ctx.drawImage(tempCanvas, 0, 0, prevCanvasActualCSSWidth, prevCanvasActualCSSHeight);
            }
            console.log(`Canvas resized. Target CSS: ${targetCSSWidth}x${targetCSSHeight}`);
            
            if (lastPaintedPixel) { startBlinkingLastPixel(); } 
            else { stopBlinkingLastPixel(); }
        }
        
        setCanvasSizeButton.addEventListener('click', () => {
            const newWidth = parseInt(canvasWidthInput.value);
            const newHeight = parseInt(canvasHeightInput.value);
            if (isNaN(newWidth) || newWidth < 1 || isNaN(newHeight) || newHeight < 1) {
                alert("Please enter valid positive numbers for width and height."); return;
            }
            specifiedCSSWidth = newWidth; specifiedCSSHeight = newHeight;
            initialSizeApplied = true;
            resizeAndPreserveCanvas();
        });

        // --- PAINTING LOGIC ---
        function paintPixel(x_css, y_css, color) {
            if (x_css < 0 || x_css >= specifiedCSSWidth || y_css < 0 || y_css >= specifiedCSSHeight) return;
            
            if (lastPaintedPixel && lastPaintedPixel.x === x_css && lastPaintedPixel.y === y_css) {
                previewCtx.clearRect(lastPaintedPixel.x, lastPaintedPixel.y, 1, 1);
            }
            else if (lastPaintedPixel) {
                 previewCtx.clearRect(lastPaintedPixel.x, lastPaintedPixel.y, 1, 1);
            }

            ctx.fillStyle = color;
            ctx.fillRect(Math.floor(x_css), Math.floor(y_css), 1, 1);
            
            lastPaintedPixel = { x: Math.floor(x_css), y: Math.floor(y_css) };
            lastPixelCoordsDisplay.textContent = `${lastPaintedPixel.x}, ${lastPaintedPixel.y}`;
            
            startBlinkingLastPixel();
        }

        // --- MOUSE/INTERACTION HANDLERS ---
        function handleInteraction(event, isMoveEvent = false) {
            if (isMoveEvent && !isPainting) return;
            if (event.type === 'mousedown') { isPainting = true; window.focus(); }

            const rect = canvas.getBoundingClientRect();
            const x_css = Math.floor(event.clientX - rect.left);
            const y_css = Math.floor(event.clientY - rect.top);
            paintPixel(x_css, y_css, isErasing ? eraserColor : currentColor);
        }
        canvas.addEventListener('mousedown', (e) => handleInteraction(e));
        canvas.addEventListener('mousemove', (e) => handleInteraction(e, true));
        document.addEventListener('mouseup', () => { isPainting = false; });

        // --- LAST PAINTED PIXEL BLINK LOGIC ---
        function getPixelColorFromMainCanvas(x_css, y_css) {
            if (x_css < 0 || x_css >= specifiedCSSWidth || y_css < 0 || y_css >= specifiedCSSHeight) {
                return [0,0,0,255]; 
            }
            const deviceX = Math.floor(x_css * currentDPR);
            const deviceY = Math.floor(y_css * currentDPR);
            try {
                return ctx.getImageData(deviceX, deviceY, 1, 1).data;
            } catch (e) {
                console.warn("Could not getImageData for preview.", e);
                return [0,0,0,255];
            }
        }

        function getNegativeColor(r, g, b) { return `rgb(${255-r}, ${255-g}, ${255-b})`; }

        function updateLastPixelBlink() {
            if (!lastPaintedPixel) {
                previewCtx.clearRect(0, 0, specifiedCSSWidth, specifiedCSSHeight);
                return;
            }
            
            previewCtx.clearRect(lastPaintedPixel.x, lastPaintedPixel.y, 1, 1);

            if (previewBlinkState) { 
                const originalPixelData = getPixelColorFromMainCanvas(lastPaintedPixel.x, lastPaintedPixel.y);
                previewCtx.fillStyle = getNegativeColor(originalPixelData[0], originalPixelData[1], originalPixelData[2]);
                previewCtx.fillRect(lastPaintedPixel.x, lastPaintedPixel.y, 1, 1);
            }
        }

        function startBlinkingLastPixel() {
            stopBlinkingLastPixel(); 
            if (!lastPaintedPixel) return;

            blinkInterval = setInterval(() => {
                previewBlinkState = !previewBlinkState;
                updateLastPixelBlink();
            }, 400);
            previewBlinkState = true; 
            updateLastPixelBlink();
        }

        function stopBlinkingLastPixel() {
            if (blinkInterval) {
                clearInterval(blinkInterval);
                blinkInterval = null;
            }
            if (lastPaintedPixel) {
                 previewCtx.clearRect(lastPaintedPixel.x, lastPaintedPixel.y, 1, 1);
            } else {
                 previewCtx.clearRect(0,0, specifiedCSSWidth, specifiedCSSHeight);
            }
            previewBlinkState = false;
        }

        // --- TOOLBAR ACTIONS (Color, Eraser, Clear) ---
        colorPicker.addEventListener('input', (e) => {
             setColor(e.target.value);
        });
        eraserButton.addEventListener('click', () => {
            isErasing = !isErasing;
            eraserButton.classList.toggle('active', isErasing);
            eraserButton.style.backgroundColor = isErasing ? '#999' : '';
            updateActiveSwatch(isErasing ? null : currentColor);
        });

        clearButton.addEventListener('click', () => {
            clearButton.style.display = 'none';
            clearConfirmationDiv.style.display = 'flex';
        });

        confirmClearYesButton.addEventListener('click', () => {
            ctx.fillStyle = defaultCanvasColor;
            ctx.fillRect(0, 0, specifiedCSSWidth, specifiedCSSHeight);
            lastPaintedPixel = null;
            lastPixelCoordsDisplay.textContent = "-";
            stopBlinkingLastPixel();
            
            clearConfirmationDiv.style.display = 'none';
            clearButton.style.display = 'inline-block';
        });

        confirmClearNoButton.addEventListener('click', () => {
            clearConfirmationDiv.style.display = 'none';
            clearButton.style.display = 'inline-block';
        });


        // --- LOAD/DOWNLOAD IMAGE ---
        downloadButton.addEventListener('click', () => {
            const dataURL = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'pixel-art.png';
            link.href = dataURL;
            link.click();
        });

        loadButton.addEventListener('click', () => loadImageInput.click());
        loadImageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (eventReader) => {
                const img = new Image();
                img.onload = () => {
                    ctx.fillStyle = defaultCanvasColor;
                    ctx.fillRect(0, 0, specifiedCSSWidth, specifiedCSSHeight);
                    ctx.drawImage(img, 0, 0, specifiedCSSWidth, specifiedCSSHeight); // Draw to fit current canvas
                    lastPaintedPixel = null;
                    lastPixelCoordsDisplay.textContent = "-";
                    stopBlinkingLastPixel();
                }
                img.onerror = () => alert("Could not load image.");
                img.src = eventReader.target.result;
            }
            reader.readAsDataURL(file);
            e.target.value = null;
        });


        // --- FULLSCREEN LOGIC ---
        function isFullscreen() { return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement; }
        function toggleFullscreen() {
            if (!isFullscreen()) {
                const el = appWrapper;
                if (el.requestFullscreen) el.requestFullscreen();
                else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
                else if (el.msRequestFullscreen) el.msRequestFullscreen();
                else if (el.mozRequestFullScreen) el.mozRequestFullScreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                else if (document.msExitFullscreen) document.msExitFullscreen();
                else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
            }
        }
        fullscreenButton.addEventListener('click', toggleFullscreen);
        function onFullscreenChange() {
            fullscreenButton.textContent = isFullscreen() ? 'Exit Fullscreen' : 'Fullscreen';
            fullscreenButton.classList.toggle('active', isFullscreen());
            setTimeout(resizeAndPreserveCanvas, 50);
        }
        document.addEventListener('fullscreenchange', onFullscreenChange);
        document.addEventListener('webkitfullscreenchange', onFullscreenChange);
        document.addEventListener('mozfullscreenchange', onFullscreenChange);
        document.addEventListener('MSFullscreenChange', onFullscreenChange);

        // --- KEYBOARD SHORTCUTS (Arrow Keys & Color Numbers) ---
        window.addEventListener('keydown', (e) => {
            if (document.activeElement === colorPicker || 
                document.activeElement === canvasWidthInput ||
                document.activeElement === canvasHeightInput) return;

            // Arrow key painting
            if (lastPaintedPixel) {
                let dx = 0; dy = 0;
                switch (e.key) {
                    case 'ArrowUp': dy = -1; break; case 'ArrowDown': dy = 1; break;
                    case 'ArrowLeft': dx = -1; break; case 'ArrowRight': dx = 1; break;
                }
                if (dx !== 0 || dy !== 0) {
                    e.preventDefault();
                    const newX_css = lastPaintedPixel.x + dx;
                    const newY_css = lastPaintedPixel.y + dy;
                    if (newX_css >= 0 && newX_css < specifiedCSSWidth && newY_css >= 0 && newY_css < specifiedCSSHeight) {
                         paintPixel(newX_css, newY_css, isErasing ? eraserColor : currentColor);
                    }
                    return; // Processed arrow key, no need to check for color keys
                }
            }

            // Number key color selection
            if (colorKeyMap.hasOwnProperty(e.key)) {
                e.preventDefault();
                setColor(colorKeyMap[e.key]);
            }
        });

        // --- INITIAL SETUP ---
        createSwatches();
        specifiedCSSWidth = parseInt(canvasWidthInput.value) || 640;
        specifiedCSSHeight = parseInt(canvasHeightInput.value) || 480;
        initialSizeApplied = true;

        resizeAndPreserveCanvas();
        setColor(currentColor); // Ensure initial color and swatch are set
        onFullscreenChange();

        let resizeDebounceTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeDebounceTimeout);
            resizeDebounceTimeout = setTimeout(() => {
                if (!isFullscreen()) {
                     resizeAndPreserveCanvas();
                }
            }, 150);
        });

    </script>
</body>
</html>
